Verilog BCH encoder/decoder.

This is a Verilog based BCH encoder and decoder for single bit, dual bit, and
3 or more bit error correction. The equations and layout for the encoder
and decoders is taken from "The design of a vhdl based synthesis tool for bch
codecs." by Ernest Jamro.

The decoder/encoder is completely parameterizable. The two main parameter
are:

DATA_BITS - The number of data bits
T - The number of bits that can be corrected

The module bch_param generates a BCH parameter set:

	`include "bch_params.vh"
	localparam [`BCH_PARAM_SZ-1:0] P = bch_params(DATA_BITS, T);

The generated parameters are passed to the BCH modules and can be access
with the following:

`BCH_M(P)		- Degree of the field
`BCH_N(P)		- Actual code size (padded)
`BCH_K(P)		- Actual data size (padded)
`BCH_T(P)		- Actual bits corrected (may be more than specified)
`BCH_DATA_BITS(P)	- Data bits
`BCH_ECC_BITS(P)	- Generate ECC bits
`BCH_CODE_BITS(P)	- Data bits + ECC bits
`BCH_SYNDROMES_SZ(P)	- Bits required for syndromes passed between modules
`BCH_SIGMA_SZ(P)	- Bits required for sigma equation passed between
			  modules
`BCH_ERR_SZ(P)		- Bits required for number of errors
`BCH_PARAM_SZ		- Bits required to hold parameters;

Parameters:

The module bch_param generates a BCH parameter set:

local_param P = bch_params(DATA_BITS, T);

The generated parameters are passed to the BCH modules and can be access
with the following:

`BCH_M(P)		- Degree of the field
`BCH_N(P)		- Actual code size (padded)
`BCH_K(P)		- Actual data size (padded)
`BCH_T(P)		- Actual bits corrected (may be more than specified)
`BCH_DATA_BITS(P)	- Data bits
`BCH_ECC_BITS(P)	- Generate ECC bits
`BCH_CODE_BITS(P)	- Data bits + ECC bits
`BCH_SYNDROMES_SZ(P)	- Bits required for syndromes passed between modules
`BCH_SIGMA_SZ(P)	- Bits required for sigmal equation passed between
			  modules
`BCH_ERR_SZ(P)		- Bits required for number of errors

Note that the number of errors correctable for a given polynomial is sparse.
The search function will choose the next highest number of correctable
errors rather than trying to move to the next polynomial. For instance, if
DATA_BITS=64, T=8 is seleceted, (127, 71, 9) is chosen rather than
(255, 191, 8).

Modules:

bch_encode - Performs encoding of input data via a large LFSR. Takes a BITS
wide input. For the first ceil(`BCH_DATA_BITS / BITS) cycles (including
cycle 0) the output mirrors the input. Then, for ceil(`BCH_ECC_BITS / BITS)
cycles the output contains the ECC bits. In the case that `BCH_DATA_BITS %
BITS is non-zero, the high bits of the last data word will be ignored.
A pipeline stage can be added by setting the PIPELINE_STAGES = 1 parameter.

bch_syndrome - Calculates the syndrome equations. Takes a BITS wide input.
Operates for ceil(`BCH_CODE_BITS / BITS) cycles to produce the compact
syndrome equations. Note that bch_syndrome expects the data and ecc input
to be merged together without pad bits in the case of `BCH_DATA_BITS %
BITS being non-zero, which is not what bch_encode produces. It is
recommended to make BITS divisible by `BCH_DATA_BITS. In the event that
`BCH_CODE_BITS % BITS is non-zero, the upper bits of the final word are
ignored. Up to two pipeline stages can be added by setting the
PIPELINE_STAGES parameter.

bch_errors_present - Determines based on syndromes if any errors are present
(Not required for decoding). Currently does not have a clock, but it may
required for large `BCH_M(P) values as it needs to or together
`BCH_M(P)*(`BCH_T(P)+1) inputs. This module can be used to allow several
bch_syndrome modules to share bch_sigma_* and bch_error_* modules or to
determine that the error is data free before allowing bch_sigma_* to complete.
Up to two pipeline stages can be added by setting the PIPELINE_STAGES
parameter.

bch_sigma_* - Key equation solvers (sigma). Takes syndrome equations as input
and produces the key equation, as well as the number of bit errors detected.
Solving the key equation is required for T > 2 and optional for T == 2, and
not supported for T == 1.

bch_sigma_bma_serial - Serial Berlekamp–Massey algorithm with inversion.
This option is not supported for pentanomials yet (eg, `BCH_M(P)=8) as the
inverter lacks pentanomial support. This option takes longer but requires
less space than the parallel option. This option takes
`BCH_T(P) * (`BCH_M(P) + 2) - 2 cycles to solve the key equation.

bch_sigma_bma_parallel - Parallel Berlekamp–Massey algorithm without
inversion. This option supports pentanomials and trinomials in less cycles
than the serial option, but requires more gates. This option takes
`BCH_T(P) * 2 - 1 cycles to solve the key equation.

bch_error_* - Error locator. After 2 cycles, it clocks out a BITS wide error
bits word ceil(`BCH_DATA_BITS / BITS) cycles, each cycle representing a set
of error locations. If `BCH_DATA_BITS % BITS is non-zero, the high bits
of the last word in the output are masked.

bch_error_dec - Error location function for T < 3. Takes syndromes directly
as input rather than a solved key equation. Same output as bch_error_*
above, but also produces the error_count. Up to two pipeline stages for
T==2 or one for T==1 can be added by setting the PIPELINE_STAGES parameter.

bch_error_tmec - Error location function for T > 1. Requires the solved key
equation as input. Same output as bch_error_* above. Up to two pipeline
stages can be added by setting the PIPELINE_STAGES parameter.

sim - Test bench core and example code for connecting together the different
modules. Takes an additional parameter to specify the type of key equation
solver:

OPTION - The type of key equation solver:

OPTION == NONE - For T < 3, skip the key solving process
OPTION == PARALLEL - For T > 1, use bch_sigma_bma_parallel
OPTION == SERIAL - For T > 1, use bch_sigma_bma_serial

BITS - The word width for bch_encode, bch_syndrome, and bch_error_*.

REG_RATIO - When using multi-bit datastreams, bch_syndrome and bch_error_*
create a duplicated register set for each bit. This causes them to instead
only create a register for every REG_RATIOth bit. The additional values
are calculated asyncronously which may create timing issues, but will
reduce register usage.

The code currently compiles under Icarus Verilog and Xilinx Isim. Because
the way the parameterization is handled, simulation is slow, especially
for larger values of `BCH_M(P)*`BCH_T(P).

TODO:

Support pentanomials for serial option.

Improve simulation times.

Shared syndrome/chien stages between data streams?

Forney algorithm for error location?

BTZ algorithm for error location?

-- Russ Dill <russ.dill@asu.edu>
